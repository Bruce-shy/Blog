### 为什么JavaScript是单线程？

JavaScript语言的一大特性就是单线程，也就是说，同一个事件只能做一件事。那么为什么他不是多线程的呢？因为JavaScript的主要用途是与用户互动，以及操作DOM，这决定了它只能是单线程，否则会带来很复杂的同步问题，比如说，如果他有两个线程，一个在某个节点上添加内容，另一个线程则删除了该节点，这时浏览器就不知道以哪个线程为主了。

### 任务队列(消息队列)

```
单线程意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。如果有的时候 IO 设备很慢（比如请求数据），我们就不得不等着结果出来，再往下执行，极大地影响效率。

于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。

（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。

（2）主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。

（3）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。

（4）主线程不断重复上面的第三步。
```

下图就是主线程和任务队列的示意图。

![Event-loop](E:\Blog\docs\.vuepress\public\Event-loop.jpg)

只要主线程空了，就会去读取"任务队列"，这就是JavaScript的运行机制。这个过程会不断重复。

### 事件和回调函数

```
"任务队列"是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在"任务队列"中添加一个事件，表示相关的异步任务可以进入"执行栈"了。主线程读取"任务队列"，就是读取里面有哪些事件。

"任务队列"中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入"任务队列"，等待主线程读取。

所谓"回调函数"（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。

"任务队列"是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，"任务队列"上第一位的事件就自动进入主线程。但是，由于存在后文提到的"定时器"功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。
```

### Event Loop

Event Loop 是 JavaScript 的运行机制，主线程从"任务队列"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。

![Event-Loop](http://www.ruanyifeng.com/blogimg/asset/2014/bg2014100802.png)

### 定时器

除了放置异步任务的事件，"任务队列"还可以放置定时事件，即指定某些代码在多少时间之后执行。这叫做"定时器"（timer）功能，也就是定时执行的代码。

setTimeout()和setInterval()这两个函数它们的内部运行机制完全一样，区别在于前者指定的代码是一次性执行，后者则为反复执行。

```
setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在"任务队列"的尾部添加一个事件，因此要等到同步任务和"任务队列"现有的事件都处理完，才会得到执行。
```

需要注意的是，setTimeout()只是将事件插入了"任务队列"，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行。

### 宏任务

```
渲染事件（如解析 DOM、计算布局、绘制）；
用户交互事件（如鼠标点击、滚动页面、放大缩小等）；
JavaScript 脚本执行事件；(setTimeout setInterval 的回调函数)；
网络请求完成(XMLHttpRequest 的回调函数)、文件读写完成事件(IO)。

主线程采用一个 for 循环，不断地从这些任务队列中取出任务并执行任务。我们把这些消息队列中的任务称为宏任务。(由宿主环境引起的任务)。
```

### 微任务

```
基于微任务的技术有 MutationObserver、Promise 以及以 Promise 为基础开发出来的很多其他的技术。Process.nextTick(node 端)

微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。(由 js 本身引起的任务)

微任务可以在实时性和效率之间做一个有效的权衡。
```

通常我们把消息队列中的任务称为**宏任务**，每个宏任务中都包含了一个**微任务队列**，在执行宏任务的过程中，如果 DOM 有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了执行效率的问题。

### 流程

整体代码(script)作为宏任务，进入主线程，遇到同步的代码，按顺序执行。遇到宏任务，把它放入宏任务队列中，遇到微任务，把它放入微任务队列中，当同步代码执行完毕时，取出微任务队列中**所有的**微任务执行，如果执行过程中又产生了微任务，继续执行微任务，直到本次宏任务中的所有微任务执行完毕。然后来到宏任务队列。

只要宏任务队列不为空：

1. 从宏任务队列取出 **一个** 执行

2. 从微任务队列里面取出 **所有的** 执行，如果在这执行过程中又产生了微任务，再次重复第二步。

3. 有可能进入浏览器的重新渲染。

   - reqAnimationframe 回调

   - 执行 IntersectionObserver 回调

   - 重新绘制渲染

### 结论

**所有会进入的异步都是指的事件回调中的那部分代码**

在一个宏任务中， 分别创建一个用于回调的宏任务和微任务，无论什么时候，微任务都早于宏任务执行。