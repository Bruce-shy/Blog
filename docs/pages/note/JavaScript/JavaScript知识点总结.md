###    1. 数据类型有哪些 ？类型判断有哪些 优缺点？

基本数据类型 Boolean Null Undefined Number String Symbol BigInt

引用数据类型 Object, 包含 Date function Array

- typeof 
  - 对于非 Object的基本数据类型，除了null，均可判断
  - 对于null 返回 object
  - 对于引用数据类型，除了function，都返回object
  - 对于function 返回 function
  - typeof(typeof a) 返回 string

- instanceof

  A instanceof B 就是用来判断B的原型是否在A的原型链上

  （A 的原型链上是否有B的原型）

- 最全面: Object.prototype.toString.call 

- constructor

### 2.koa2、koa1、express 比较

在koa中，一切的流程都是中间件，数据流向遵循洋葱模型，先入后出，是按照类似堆栈的方式组织和执行的。

koa2和koa1的最大区别是koa2实现异步是通过async/await，koa1实现异步是通过generator/yield，而express实现异步是通过回调函数的方式。

koa2与express提供的API大致相同，express是大而全，内置了大多数的中间件，更让人省心，koa2不绑定任何的框架，干净简洁，小而精，更容易实现定制化，拓展性好。

express是没有提供ctx来提供上下流服务，需要更多地手动处理，express本身是不支持洋葱模型的数据流入流出能力，需要引入其他插件。

### 3. http 和 https 的区别 为什么https 就更安全呢？

http 协议是明文传输数据，在传输过程中容易被窃取或者篡改，容易遭受中间人攻击。

所以为了访问更加安全，我们引入了加密方案，在 TCP 和 HTTP 之间插入了一个安全层。安全层有两个职责，对发起 http 请求的数据进行加密操作和对接收到http的内容进行解密操作。

- 第一版 对称加密 加密和解密使用的都是相同的密钥 （速度快 安全性低）
- 第二版 非对称加密 有A、B两把密钥，如果你使用 A密钥来加密，那么只能使用B密钥来解密；反过来，如果你要用B密钥加密，那么只能使用A密钥来解密。(速度慢 安全性比较高)
- 第三版 对称加密和非对称加密搭配使用 (黑客可以通过dns劫持，这样访问的就是黑客的服务器了。)
- 第四版 添加数字证书 （更安全的做法）

### 4. 从输入 url 到页面显示发生了啥？

- DNS 解析
- HTTP 请求
- 服务器处理 HTTP 请求 并返回 HTTP 报文
- 浏览器解析渲染页面
- 连接结束

### 5.HTTP 缓存机制

强缓存：浏览器直接从本地缓存中获取数据，不与服务器进行交互。

协商缓存：浏览器发送请求到服务器，服务器判断是否可使用本地缓存。

### 6. 什么是闭包，为什么要用它？

```
红宝书：闭包是指有权访问另一个函数作用域中变量的函数，
小黄书：当函数可以记住并访问所在的词法作用域时，就产生了闭包。
MDN：闭包是指那些能够访问自由变量的函数。（其中自由变量，指在函数中使用的，但既不是函数参数arguments也不是函数的局部变量，其实就是另外一个函数作用域中的变量。）

闭包的作用: 正常函数执行完毕后,里面声明的变量被垃圾回收处理掉,但是闭包可以让作用域里的变量,在函数执行完之后依旧保持没有被垃圾回收处理掉
```

创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。

### 7.解释一下原型和原型链

```
原型：在JavaScript高级程序设计中的解释是：每个构造函数都有一个 prototype (原型) 属性，这个属性是一个指针，指向函数的原型对象，这个对象包含由特定类型的所有实例共享的属性和方法。

在默认情况下，所有的原型对象都会自动获得一个 constructor （构造函数）属性，这个属性指向 prototype 属性所在函数的指针。

当我们创建一个实例后，这个实例的内部有一个指针，指向构造函数的原型对象。ES5把这个指针叫[[Prototype]], 在 ES6 中 我们可以通过 Object.getPrototypeOf() 和 Object.setPrototypeOf() 来访问，它等同于 JavaScript 的非标准但许多浏览器实现的属性 __proto__。

原型链：当谈到继承时，JavaScript 只有一种结构：对象。 每个实例对象(object) 都有一个私有属性(称为__proto__ ) 指向它的构造函数的原型对象 (prototype)。该原型对象也有一个自己的原型对象(__proto__), 层层向上直到一个对象的原型对象为 null。 根据定义， null 没有原型，作为原型链的终点。
```

### 7. js 延迟加载的方式有哪些？

js 延迟加载指等页面加载完成之后再加载 js 文件，这有助于提高页面加载速度。

一般有以下几种方式：

- defer 属性

- async 属性

- 动态创建 DOM 方式

- 使用 setTimeout 延迟方法

- 让 JS 最后加载

js 的加载、解析和执行会阻塞页面的渲染过程，因此我们希望js脚本能够尽可能的延迟加载，提高页面的渲染速度。

### 8. null 是对象吗？ 为什么？

null不是对象，尽管 typeof null = object 。

因为这是 js 一个久远的bug，在js最初实现时，值是由一个表示类型的标签和实际数据表示的，而对象的标签是 0。又因为null 代表的是空指针，标签也是0，所以 typeof null 是 'object'。因此 null 不是 对象。

### 9. 0.1+0.2为什么不等于0.3？

0.1和0.2在转换成二进制后会无限循环，由于标准位数的限制后面多余的位数会被截掉，此时就已经出现了精度的损失，相加后因浮点数小数位的限制而截断的二进制数字在转换为十进制就会变成0.30000000000000004。

### 10. 如何理解BigInt?

```
BigInt是一种新的数据类型，用于当整数值大于Number数据类型支持的范围时。这种数据类型允许我们安全地对大整数执行算术操作，表示高分辨率的时间戳，使用大整数id，等等，而不需要使用库。
```

因为在js 中，所有的数字都以双精度64位浮点格式表示，这导致 js 中的 Number 无法精确表示非常大的整数，会出现精度问题。也会有一定的安全问题。

创建BigInt, 只需要在数字末尾追加 n 即可。

或者使用 BigInt 构造函数，BigInt("321321372198367981268")

### 11. JavaScript 有几种类型的值？ 你能画一下他们的内存图吗？

- 栈：原始数据类型（Undefined、Null、Boolean、Number、String）
- 堆：引用数据类型（对象、数组和函数）

```
两种类型的区别是：存储位置不同。
原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。

引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在
栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。
```

### 12. undefined 与 undeclared 的区别

```
已在作用域中声明但还没有赋值的变量，是 undefined 的。相反，还没有在作用域中声明过的变量，是 undeclared 的。

对于 undeclared 变量的引用，浏览器会报引用错误，如 ReferenceError: b is not defined 。但是我们可以使用 typeof 的安全防范机制来避免报错，因为对于 undeclared（或者 not defined ）变量，typeof 会返回 "undefined"。
```

### 13. null 和 undefined 的区别

```js
首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。

undefined 代表的含义是未定义，null 代表的含义是空对象。一般变量声明了但还没有定义的时候会返回 undefined，null
主要用于赋值给一些可能会返回对象的变量，作为初始化。

undefined 在 js 中不是一个保留字，这意味着我们可以使用 undefined 来作为一个变量名，这样的做法是非常危险的，它
会影响我们对 undefined 值的判断。但是我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。

当我们对两种类型使用 typeof 进行判断的时候，Null 类型化会返回 “object”，这是一个历史遗留的问题。当我们使用双等
号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。
```

```js
let a = null, b = undefined
typeof a // "object"
typeof b // "undefined"
a == b // true
a === b // false
```

### 14. 如何获取安全的 undefined 值？

```
因为 undefined 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常判断。
表达式 void ___ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。
按惯例我们用 void 0 来获得 undefined。
```

### 15.说几条写 JavaScript 的基本规范？

```
在平常项目开发中，我们遵守一些这样的基本规范，比如说：
（1）一个函数作用域中所有的变量声明应该尽量提到函数首部，用一个 var 声明，不允许出现两个连续的 var 声明，声明时
    如果变量没有值，应该给该变量赋值对应类型的初始值，便于他人阅读代码时，能够一目了然的知道变量对应的类型值。
（2）代码中出现地址、时间等字符串时需要使用常量代替。
（3）在进行比较的时候吧，尽量使用'===', '!=='代替'==', '!='。
（4）不要在内置对象的原型上添加方法，如 Array, Date。
（5）switch 语句必须带有 default 分支。
（6）for 循环必须使用大括号。
（7）if 语句必须使用大括号。
```

### 16. js 获取原型的方法？

- p.`__proto__`
- p.constructor.prototype
- Object.getPrototypeOf(p)

### 17. 在 js 中不同进制数字的表示方式

- 以 0X、0x 开头的表示为十六进制。
- 以 0、0O、0o 开头的表示为八进制。
- 以 0B、0b 开头的表示为二进制格式。

### 18.typeof NaN 的结果是什么？

```
NaN 意指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。

typeof NaN; // "number"

NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不成立）的值。而 NaN != NaN 为 true。
```

### 19. isNaN 和 Number.isNaN 函数的区别？

```
函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会
返回 true ，会影响 NaN 的判断。

函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，这种方法对于 NaN 的判断更为
准确。
```

### 20. Array 构造函数只有一个参数值时的表现？

```
Array 构造函数只带一个数字参数的时候，该参数会被作为数组的预设长度（length），而非只充当数组中的一个元素。这样
创建出来的只是一个空数组，只不过它的 length 属性被设置成了指定的值。

构造函数 Array(..) 不要求必须带 new 关键字。不带时，它会被自动补上。
```

### 21. {} 和 [] 的 valueOf 和 toString 的结果是什么？

```
{} 的 valueOf 结果为 {} ，toString 的结果为 "[object Object]"

[] 的 valueOf 结果为 [] ，toString 的结果为 ""
```

```js
[].valueOf() // []
({}).valueOf() // {}
[].toString() // ""
({}).toString() // "[object Object]"
```

### 22. || 和 && 操作符的返回值？

```
|| 和 && 首先会对第一个操作数执行条件判断，如果其不是布尔值就先进行 ToBoolean 强制类型转换，然后再执行条件
判断。

对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。

&& 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。

|| 和 && 返回它们其中一个操作数的值，而非条件判断的结果
```

### 23. == 操作符的强制类型转换规则？

```
（1）字符串和数字之间的相等比较，将字符串转换为数字之后再进行比较。

（2）其他类型和布尔类型之间的相等比较，先将布尔值转换为数字后，再应用其他规则进行比较。

（3）null 和 undefined 之间的相等比较，结果为真。其他值和它们进行比较都返回假值。// null == undefined true

（4）对象和非对象之间的相等比较，对象先调用 ToPrimitive 抽象操作后，再进行比较。

（5）如果一个操作值为 NaN ，则相等比较返回 false（ NaN 本身也不等于 NaN ）。

（6）如果两个操作值都是对象，则比较它们是不是指向同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true，否则，返回 false。
```

### 24. javascript 代码中的 "use strict"; 是什么意思 ? 使用它区别是什么？

```
use strict 是一种 ECMAscript5 添加的（严格）运行模式，这种模式使得 Javascript 在更严格的条件下运行。

设立"严格模式"的目的，主要有以下几个：
```

- 消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为;
- 消除代码运行的一些不安全之处，保证代码运行的安全；
- 提高编译器效率，增加运行速度；
- 为未来新版本的 Javascript 做好铺垫。

区别：

- 1.禁止使用 with 语句。
- 2.禁止 this 关键字指向全局对象。
- 3.对象不能有重名的属性。

### 25. Ajax 是什么? 如何创建一个 Ajax？

Ajax 指的是通过 JavaScript 的 异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用再刷新整个网页。

Ajax 返回的状态

- 0 - (未初始化) 还没有调用 send() 方法。
- 1 - (载入) 已调用 send() 方法，正在发送请求。
- 2 - (载入完成) send() 方法执行完成，已经接受到全部的响应内容。
- 3 - (交互) 正在解析响应内容。
- 4 - (完成) 响应内容解析完成， 可以在客户端调用了。

步骤如下：

- 1 设置请求参数 (请求方式， 请求页面的相对路径，是否异步)。
- 2 设置回调函数，一个处理服务器响应的函数，使用 onreadystatechange，类似函数指针。
- 3 获取异步对象的 readyState 属性。该属性存有服务器响应的状态信息。每当 readyState 改变时，onreadystatechange 函数就会被执行。
- 4 判断响应报文的状态，若为 200 说明服务器正常运行并返回响应数据。
- 5 读取响应数据，可以通过 response Text 属性来取回由服务器返回的数据。

```js
// 手写一个 ajax 函数
function ajax({url, method, data, timeout}) {
    // 原生 XMLHttpRequest
    return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest()
        xhr.timeout = timeout;
        xhr.open(method, url, true)
        xhr.ontimeout = function() {
            reject('timeout')
        }
        xhr.onreadystatechange = function () {
            // xhr 代理的状态
            if (xhr.readyState === 4){
                // xhr 请求的状态
                if((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304) {
                    let res = JSON.parse(xhr.response);
                    resolve(res);
                }else {
                    reject('response error')
                }
            }
        }
    })
}
```

Fetch 和 Ajax 比有什么优缺点？

promise 方便异步，在不想用jQuery的情况下， 相比原生的ajax，也比较好写。

### 26. async 本质是什么？await 后得到的是什么值？

```
async 是一个通过异步执行并隐式返回 Promise 作为结果的函数。
重点: (异步执行和隐式返回 Promise。)

async 函数返回的是一个 Promise 对象

await 返回 Promise 对象的处理结果。如果等待的不是 Promise 对象，则返回该值本身。
```

### 27. 同步和异步的区别？

```
同步指的是当一个进程在执行某个请求的时候，如果这个请求需要等待一段时间才能返回，那么这个进程会一直等待下去，直到消息返回为止再继续向下执行。

异步指的是当一个进程在执行某个请求的时候，如果这个请求需要等待一段时间才能返回，这个时候进程会继续往下执行，不会阻塞等待消息的返回，当消息返回时系统再通知进程进行处理。
```

### 28.谈谈你对 webpack 的看法

```
我当时使用 webpack 的一个最主要原因是为了简化页面依赖的管理，并且通过将其打包为一个文件来降低页面加载时请求的资源数。

我认为 webpack 的主要原理是，它将所有的资源都看成是一个模块，并且把页面逻辑当作一个整体，通过一个给定的入口文件，webpack 从这个文件开始，找到所有的依赖文件，将各个依赖文件模块通过 loader 和 plugins 处理后，然后打包在一起，最后输出一个浏览器可识别的 JS 文件。

Webpack 具有四个核心的概念，分别是 Entry（入口）、Output（输出）、loader 和 Plugin（插件）。

1. Entry 是 webpack 的入口起点，它指示 webpack 应该从哪个模块开始着手，来作为其构建内部依赖图的开始。
2. Output 属性告诉 webpack 在哪里输出它所创建的打包文件，也可指定打包文件的名称，默认位置为 ./dist。
3. Loader 可以理解为 webpack 的编译器，它使得 webpack 可以处理一些非 JavaScript 文件。在对 loader 进行配置的时候，test 属性，标志有哪些后缀的文件应该被处理，是一个正则表达式。use 属性，指定 test 类型的文件应该使用哪个 loader 进行预处理。常用的 loader 有 css-loader、style-loader 等。
4. Plugin 插件可以用于执行范围更广的任务，包括打包、优化、压缩、搭建服务器等等，要使用一个插件，一般是先使用 npm 包管理器进行安装，然后在配置文件中引入，最后将其实例化后传递给 plugins 数组属性。
```

### 29. 谈一谈你理解的函数式编程？

```
简单说，"函数式编程"是一种"编程范式"（programming paradigm），也就是如何编写程序的方法论。

它具有以下特性：闭包和高阶函数、惰性计算、递归、函数是"第一等公民"、只用"表达式"。
```

### 30. parseInt('8','9','9') 和 parseInt('8','9','10') waht & why ?

```
map 函数的第一个参数 callback
这个callback一共可以接收三个参数，其中第一个参数代表当前被处理的元素，而第二个参数代表该元素的索引。第三个参数是数组本身。

而parseInt则是用来解析字符串的，使字符串成为指定基数的整数。
parseInt(string, radix)从 2 到 36
接收两个参数，第一个表示被处理的值（字符串），第二个表示为解析时的基数。

所以
parseInt(8,0) => 8 (如果radix没有指定或者为0，参数会被假定以10为基数来解析，如果数值以字符对0x或0X开头，会假定以16为基数来解析。)
parseInt(9,1) => NAN
parseInt(9,2) => NAN
parseInt(10,2) => 2
```

### 31. var 变量提升

```
JavaScript 仅提升声明，而不提升初始化。如果你先使用的变量，再声明并初始化它，变量的值将是 undefined。

与通过 var 声明的有初始化值 undefined 的变量不同，通过 let 声明的变量直到它们的定义被执行时才初始化。在变量初始化前访问该变量会导致 ReferenceError。该变量处在一个自块顶部到初始化处理的“暂存死区”中。

let 和 const 不存在变量提升，他们存在暂时性死区(只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。)

ES6 规定暂时性死区和let、const语句不出现变量提升
```

### 32. `<a href="" onClick={}>`是先跳转还是先 触发 onClick ？

```
先触发 onclick，再跳转，好比 <Link /> 组件
如果不想执行 href 属性下的动作，onclick 需要返回 false
```

### 33. Link引入的css和import引入的css有啥区别

```
1、link引入的Css可以同时加载，@import引入的Css是在页面加载完毕后再加载
2、link是html标签，没有兼容性问题，而@import是css2之后引入的，存在一定的兼容性问题，但是目前来看，由于基本都是CSS2-Css3了，因此使用上没有啥兼容性问题了
3、JS可以通过DOM操作link标签，但是无法操作@import
4、当然一般建议优先使用link，减少使用@import
```
